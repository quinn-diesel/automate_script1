from .base import BaseApi, rex_result
from pyrex.api import contacts, users, common
import traceback


class ListingsApi(BaseApi):
    @rex_result()
    def get(self, listing_id, raw=False):
        data = {
            "id": listing_id,
            "extra_fields": [
                "_overrides",
                "_security_user_rights",
                "_publication_status",
                "_portal_errors_preventing_upload",
                "_portal_statuses",
                "_auto_update_status",
            ],
        }
        return self.client.request_beta("Listings::read", data)

    @rex_result()
    def get_current_sale_listings(
        self, offset=0, limit=100, exclude_draft=True, order_desc=True, raw=False
    ):

        order_by = "desc" if order_desc else "asc"
        criteria = [
            {
                "name": "listing.listing_category_id",
                "type": "in",
                "value": [
                    "land_sale",
                    "commercial_sale",
                    "business_sale",
                    "residential_sale",
                    "rural_sale",
                ],
            },
            {"name": "listing.system_listing_state", "type": "=", "value": "current"},
        ]
        if exclude_draft:
            criteria.append(
                {
                    "name": "listing.system_publication_status",
                    "type": "in",
                    "value": ["published"],
                }
            )
        data = {
            "criteria": criteria,
            "limit": limit,
            "offset": offset,
            "order_by": {"system_ctime": order_by},
        }
        return self.client.request_beta("Listings::search", data)

    @rex_result(return_key="_id")
    def create(
        self, property_id, listing_category_id="residential_sale", location_id=None
    ):
        """
        This method will  create listing  for given property id returns the
        created listing

        :param  property_id: '_id' in the property data
        :param  listing_category_id:  By defalut this value will be
                residential_sale and you can override this  value by
                passing any valid listing type
        :param location_id: Agent location id,
        :type property_id : str
        :type listing_category_id : str
        :type location_id : int
        :return  listing_id
        """
        user = users.UsersApi(self.client)
        if location_id is None:
            location_id = user.get_location_id()
        property_id = int(property_id)
        location_id = str(location_id)
        data = {
            "data": {
                "listing_category_id": listing_category_id,
                "location_id": location_id,
                "property": {"id": property_id},
            }
        }
        return self.client.request_beta("Listings::create", data)

    @rex_result()
    def archive_listing_as_withdrawn(self, listing_id, reason_id, reason_note):
        """
        To update listing as withdrawn

        :type listing_id: int
        :type reason_id:str
        :type reason_note:str
        """
        state = "withdrawn"
        details = {
            "data": "None",
            "listingId": listing_id,
            "purchtenant_ids": [],
            "state": state,
            "reason_id": reason_id,
            "reason_note": reason_note,
            "update_property_contacts": True,
            "value_price": None,
        }

        data = {"details": details, "id": listing_id, "state": state}
        return self.client.request_beta("Listings::changeState", data)

    @rex_result()
    def create_or_update_event(
        self,
        listing_id,
        property_id,
        event_date,
        agent_id,
        event_start_time,
        event_end_time,
        event_id=None,
    ):
        """
        this method will create/update open home  events in specified  listing,
        if event_id is not None then it will update ,else creation will takes
        place

        :type listing_id : int
        :type property_id:int
        :type event_date :  str
        :type set_date: str
        :type event_start_time :str
        :type event_end_timeL: str
        :type agent_id: int
        :type event_id: int
        :param listing_id : listing id
        :param property_id: property id
        :param event_date : date of open home inspection(YYYY-MM-DD)
        :param agent_id : organiser agent name
        :param event_start_time : start time of open  home inspection(HH:mm:ss)
        :param event_end_time : start time of open  home inspection(HH:mm:ss)
        :param event_id : the event id which you want to update

        """
        user = users.UsersApi(self.client)

        events = self.get_events(listing_id)
        agent_name = user.get_agent_name(agent_id)
        new_event = {
            "event_type": "open_home",
            "event_time": event_start_time,
            "event_date": event_date,
            "event_duration_minutes": common.get_minutes(
                event_start_time, event_end_time
            ),
            "event_agent": {
                "id": agent_id,
                "label": agent_name,
                "term": agent_name,
                "value": agent_name,
            },
            "_id": event_id,
        }

        if event_id is None:
            events.append(new_event)
        else:
            temp_events = events
            for event in temp_events:
                if event["_id"] == event_id:
                    events.remove(event)
                    events.append(new_event)

        data = {
            "data": {
                "_id": listing_id,
                "property": {"id": property_id},
                "_related": {"listing_events": events},
            },
            "fields": ["_related.listing_events"],
        }
        return self.client.request_beta("Listings::update", data)

    @rex_result()
    def delete_listing_event(self, listing_id, property_id, event_id):
        """
        Delete the open home event  of listing

        :type listing_id:int
        :type property_id:int
        :event_id :int
        :rtype : {}
        """

        events = self.get_events(listing_id)
        for event in events:
            if event["_id"] == int(event_id):
                event["_destroy"] = True
                data = {
                    "data": {
                        "_id": listing_id,
                        "property": {"id": property_id},
                        "_related": {"listing_events": events},
                    },
                    "fields": ["_related.listing_events"],
                }
                return self.client.request_beta("Listings::update", data)

    @rex_result(return_key="listing_events")
    def get_events(self, listing_id):
        """
        events are part of  listing data so we are fetching events from listing
        data

        :listing_id:int
        :rtype :[]
        :return : events_list
        """
        response = self.get(listing_id)
        new_response = {"result": response["_related"]}
        return new_response

    @rex_result()
    def get_listing(self, full_address):
        """
        To fetch current listing

        :type full_address:str address of current listing
        """
        data = {
            "requests": {
                "CURRENT_LISTING": {
                    "method": "Listings::autocomplete",
                    "args": {"listing_states": ["current"]},
                }
            },
            "shared_args": {"search_string": full_address, "limit": 1},
        }
        # with 'Listings::autocomplete' service we are not able to add args thats why i am calling BatchRequest
        return self.client.request("BatchRequests::execute", data)

    def get_updated_listings(self, limit, offset):
        data = {
            "criteria": [
                {
                    "name": "listing.system_listing_state",
                    "type": "=",
                    "value": "current",
                }
            ],
            "limit": limit,
            "offset": offset,
            "extra_options": {},
            "order_by": {"system_modtime": "desc"},
        }
        return self.client.request("Listings::search", data)

    @rex_result()
    def set_listing_details(
        self,
        listing_id,
        agent_id_1=None,
        agent_id_2=None,
        date_listed=None,
        expires=None,
        authority=None,
        new_home=False,
        authority_date=None,
        authority_time=None,
    ):
        """
        sets data such as agent details,date,expired date,authority 
        in 'listing_details' section under 'key details' tab
        and authority_date,authority_time in 'Auction' under 'Events' tab
        """
        data = {
            "service_name": "Listings",
            "service_object_id": listing_id,
            "data": {
                "new_home": new_home,
                "_id": listing_id,
                "property": {"id": self.get(listing_id)["property"]["id"]},
            },
            "value_map": {},
            "return_custom_fields_keyed_by": "field_id",
        }
        if agent_id_1 != None:
            data["data"]["listing_agent_1"] = {"id": agent_id_1}
        if agent_id_2 != None:
            data["data"]["listing_agent_2"] = {"id": agent_id_2}
        if date_listed != None or expires != None:
            if date_listed != None:
                data["data"]["authority_date_start"] = date_listed
            if expires != None:
                data["data"]["authority_date_expires"] = expires
            if date_listed != None and expires != None:
                data["data"]["authority_duration_days"] = common.get_duration_days(
                    date_listed, expires
                )
        if authority != None:
            data["data"]["authority_type"] = {
                "id": authority.lower(),
                "text": authority.title(),
            }
        if authority != None:
            data["data"]["_related"] = {
                "listing_events": [
                    {
                        "event_type": authority,
                        "event_time": authority_time,
                        "event_date": authority_date,
                    }
                ]
            }
        return self.client.request_beta(
            "CustomFields::setFieldValuesAndUpdateRecord", data
        )

    @rex_result()
    def set_price(self, listing_id, price_advertise_as=None, price_match_as=None):
        """
        sets price_advertise_as and price_match_as in 'Price' section under 'Key Details' tab 
        """
        data = {
            "service_name": "Listings",
            "service_object_id": listing_id,
            "data": {
                "price_advertise_as": price_advertise_as,
                "price_match": price_match_as,
                "price_match_sale": price_match_as,
                "comm_est_based_on_amount": price_match_as,
            },
            "return_custom_fields_keyed_by": "field_id",
            "value_map": {},
        }
        return self.client.request_beta(
            "CustomFields::setFieldValuesAndUpdateRecord", data
        )

    @rex_result()
    def set_property_attributes(self, listing_id, bedrooms=0, bathrooms=0, carports=0):
        """
        sets property_attributes such as bedrooms,bathrooms,carports in 'Property Attributes' section under 'Key Details' tab 
        """
        data = {
            "service_name": "Listings",
            "service_object_id": listing_id,
            "data": {
                "property": {
                    "id": self.get(listing_id)["property"]["id"],
                    "attr_bedrooms": bedrooms,
                    "attr_bathrooms": bathrooms,
                    "attr_carports": carports,
                }
            },
            "return_custom_fields_keyed_by": "field_id",
            "value_map": {},
        }
        return self.client.request("CustomFields::setFieldValuesAndUpdateRecord", data)

    @rex_result()
    def set_property_subcategories(self, listing_id, subcategory_type):
        """
        sets set_property_subcategories such as subcategory_type in 'Sub Categories' section under 'More Info' tab 
        """
        if subcategory_type in common.subcategories.keys():
            data = {
                "data": {
                    "_id": listing_id,
                    "_related": {
                        "listing_subcategories": [
                            {
                                "subcategory": {
                                    "id": common.subcategories[subcategory_type]["subcategory_id"],
                                    "text": common.subcategories[subcategory_type]["rex_subcategory_type"],
                                }
                            }
                        ]
                    },
                }
            }
            return self.client.request("Listings::update", data)
        return None

    @rex_result()
    def set_features(self, listing_id, feature_name_list):
        """
        sets property features with given listing_id, feature_name_list
        feature_name_list format:["feature_name_1","feature_name_2"] example:["Study","Deck"]
        """
        feature_list = common.prepare_feature_list(feature_name_list)
        if len(feature_list) > 0:
            data = {
                "service_name": "Listings",
                "service_object_id": listing_id,
                "data": {
                    "_id": listing_id,
                    "_related": {"property_features": feature_list},
                },
                "value_map": {},
                "return_custom_fields_keyed_by": "field_id",
            }
            return self.client.request(
                "CustomFields::setFieldValuesAndUpdateRecord", data
            )
        return None

    @rex_result()
    def create_related_contact(self, listing_id, contact_id, reln_type_id="owner"):
        try:
            data = {
                "data": {
                    "_id": listing_id,
                    "_related": {
                        "contact_reln_listing": [
                            {
                                "contact": {"id": contact_id},
                                "reln_type": {"id": reln_type_id},
                            }
                        ]
                    },
                },
                "fields": ["_related.contact_reln_listing"],
            }
            return self.client.request_beta("Listings::update", data)

        except Exception:
            return {"result": {"error": traceback.format_exc()}}

    def upload_documents(self, document_details_array, listing_id):
        """
       to upload,saving documents of listing
       :type document_details_array: [{binary,name}] binary and name of the document
       :type listing_id:int
       """
        listing_documents = []
        for document_detail in document_details_array:
            # uploading document
            response = self.client.request_(
                "Upload::uploadFile", document_detail["binary"], document_detail["name"]
            )
            response = response["result"]
            doucment = {
                "description": document_detail["name"],
                "uri": response["uri"],
                "_url": response["uri"],
                "privacy": {"text": "Private", "id": "private"},
                "type": {"text": "Other", "id": "other"},
            }
            listing_documents.append(doucment)
        data = {
            "data": {
                "_id": listing_id,
                "_related": {"listing_documents": listing_documents},
            },
            "return_custom_fields_keyed_by": "field_id",
            "service_name": "Listings",
            "service_object_id": listing_id,
            "value_map": {},
        }
        # saving document
        return self.client.request("CustomFields::setFieldValuesAndUpdateRecord", data)

    @rex_result()
    def create_feedback(
        self,
        listing_id: int,
        feedback_type_id,
        _date,
        contacts_id_array=None,  # list of contact ids i.e [12345,67891]
        starttime=None,
        endtime=None,
        amount_of: int = None,
        enquiry_source_label=None,
        interest_level=None,
        note=None,
    ):
        """
        creates feedback based on feedback type i.e, "ofi" or "inspection" 

        if feedback_type_id=="ofi"
            method:create_feedback(listing_id,feedback_type_id="ofi",contacts_id_array,_date,starttime,endtime)
            mandatory param:listing_id(type:int),feedback_type_id(type:str),_date(type:str,format:YYYY-MM-DD),starttime(type:int,format:HH:mm:ss),endtime(type:int,format:HH:mm:ss)
            optional param:contacts_id_array(type:list)
        if feedback_type_id=="inspection"  
            method:create_feedback(listing_id,feedback_type_id="inspection",contacts_id_array,_date,amount_of,enquiry_source_label,interest_level)
            mandatory param:listing_id,feedback_type_id,_date
            optional param:contacts_id_array,amount_of(type:int),enquiry_source_label(type:str),interest_level(type:str)  
        """
        feedback_type_id_mapping = [
            {"id": "ofi", "text": "OFI"},
            {"id": "inspection", "text": "Private Inspection"},
        ]
        feedback_type = {}
        for i in feedback_type_id_mapping:
            if i["id"] == feedback_type_id:
                feedback_type = i
        data = {
            "data": {
                "feedback_type": feedback_type,
                "date_of": _date,
                "note": note,
                "listing": {"id": listing_id},
            }
        }
        if contacts_id_array != None:
            attendees_list = []
            for contact_id in contacts_id_array:
                attendees_list.append({"contact": {"id": contact_id}})
            data["data"]["_related"] = {"feedback_contacts": attendees_list}
            data["data"]["number_of_people"] = len(contacts_id_array)
        new_data = ""
        if feedback_type_id == "ofi":
            new_data = common.prepare_ofi_feedback_data(data, _date, starttime, endtime)
        elif feedback_type_id == "inspection":
            new_data = common.prepare_inspection_feedback_data(
                data, amount_of, enquiry_source_label, interest_level
            )
        return self.client.request_beta("Feedback::create", new_data)

    @rex_result()
    def get_feedbacks(self, listing_id):
        data = {
            "criteria": [{"name": "listing_id", "type": "=", "value": listing_id}],
            "extra_options": {},
            "order_by": {"system_ctime": "desc"},
        }
        return self.client.request_beta("Feedback::search", data)

    @rex_result()
    def update_feedback(self, listing_id, contact_id, interest_level):
        feedbacks = self.get_feedbacks(listing_id)
        for feedback in feedbacks:
            feedback_id = feedback["_id"]
            feedback_contacts = feedback["_related"]["feedback_contacts"]
            if len(feedback_contacts) > 0:
                for feedback_contact in feedback_contacts:
                    if contact_id == int(feedback_contact["contact"]["id"]):
                        self.update_feedback_interest(
                            listing_id, feedback_id, interest_level
                        )

        return None

    @rex_result()
    def update_feedback_interest(self, listing_id, feedback_id, interest_level):
        data = {
            "data": {
                "feedback_type": {"id": "inspection", "text": "Private Inspection"},
                "listing": {"id": listing_id},
                "interest_level": {"id": interest_level.lower()},
                "_id": feedback_id,
            },
            "fields": [],
        }
        return self.client.request_beta("Feedback::update", data)

